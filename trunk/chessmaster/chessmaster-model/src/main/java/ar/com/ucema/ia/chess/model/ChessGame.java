package ar.com.ucema.ia.chess.model;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import aima.search.framework.Problem;import aima.search.framework.Search;import aima.search.uninformed.DepthLimitedSearch;import ar.com.ucema.ia.chess.iama.ChessGoalTest;import ar.com.ucema.ia.chess.iama.ChessHeuristicFunction;import ar.com.ucema.ia.chess.iama.ChessInteligentAgent;import ar.com.ucema.ia.chess.iama.ChessSuccessorFunction;import ar.com.ucema.ia.chess.model.exceptions.PlayFoundException;/** *  * @author matiassuarez * */public class ChessGame {	private static ChessGame game = new ChessGame();	private ChessBoard board;	private Color colorToPlayNext;	private Integer maxDepthLimit = 2;			private ChessGame() {		createBoard();	}	private void createBoard() {		this.board = new ChessBoard();		this.colorToPlayNext = Color.White;	}		public static ChessGame getInstance() {		return game;	}	public Color getColorToPlayNext() {		return colorToPlayNext;	}	public ChessBoard getBoard() {		return board;	}	public void setBoard(ChessBoard board) {		this.board = board;	}	public Document toXML() {		Document doc = DocumentHelper.createDocument();		Element root = doc.addElement("game");		board.toXML(root);				return doc;	}	public void playWith(ChessPlay aPlay) {		ChessMovement move = buildMovementFor(aPlay);		ChessBoard board = game.getBoard();				Boolean movementMade = board.moveWithThis(move);		if ( movementMade )			game.colorToPlayNext = game.getColorToPlayNext().negate();	}	private ChessMovement buildMovementFor(ChessPlay aPlay) {		ChessCell from = new ChessCell(aPlay.getColumnFrom(), aPlay.getRowFrom());		ChessCell to = new ChessCell(aPlay.getColumnTo(), aPlay.getRowTo());		ChessGame game = ChessGame.getInstance();				ChessMovement move = (game.getColorToPlayNext().equals(Color.White)) ? new WhitePieceChessMovement(from, to, game.getBoard()) : new BlackPieceChessMovement(from, to, game.getBoard());		return move;	}	public void playBlack() {		try {			Problem problem = new Problem(ChessGame.getInstance().getBoard(), new ChessSuccessorFunction(), new ChessGoalTest(), new ChessHeuristicFunction(), new ChessHeuristicFunction());			Search search = new DepthLimitedSearch(maxDepthLimit);//			Search search = new HillClimbingSearch();//			Search search = new AStarSearch(new GraphSearch());						ChessInteligentAgent agent = new ChessInteligentAgent(problem, search);			String moveAsString = getBestPlay(agent.getActions());			playWith(getChessPlayFromString(moveAsString));			agent.printActions();		} catch (PlayFoundException e) {			ChessGame.getInstance().setBoard(e.getBoard());		} catch (Exception e) {			e.printStackTrace();		}	}			public void playBlackReleoded() {		ChessBoard originalBoard = ChessGame.getInstance().getBoard();		List<BlackPieceChessMovement> movements = originalBoard.getAllPosibleBlackPiecesMovements();		ChessHeuristicFunction function = new ChessHeuristicFunction();				Integer minHeuristic = 200;		BlackPieceChessMovement minHeuristicMovement = null;		List<Integer> heuristicValues = new ArrayList<Integer>();		List<BlackPieceChessMovement> validMovements = new ArrayList<BlackPieceChessMovement>();				for (BlackPieceChessMovement move : movements) {			ChessBoard clonedBoard = originalBoard.clone();			move.setBoard(clonedBoard);						if ( clonedBoard.isValidMovement(move) ) {				clonedBoard.moveWithThis(move);				int heuristicValue = function.getHeuristicValue(clonedBoard);				heuristicValues.add(heuristicValue);				validMovements.add(move);								if ( heuristicValue < minHeuristic ) {					minHeuristic = heuristicValue;					minHeuristicMovement = move;				}			}		}				if ( allMovesHaveSameHeuristic(heuristicValues) ) {			int randomIndex = getRandomValue(0, validMovements.size());			ChessMovement move = validMovements.get(randomIndex);			move.setBoard(originalBoard);			originalBoard.moveWithThis(move);		} else {			// reestablece el tablero original			minHeuristicMovement.setBoard(originalBoard);			originalBoard.moveWithThis(minHeuristicMovement);		}	}		private Integer getRandomValue(int min, int max) {		Random random = new Random();		random.setSeed(123131l);		int value = random.nextInt(max);		return value;	}		private boolean allMovesHaveSameHeuristic(List<Integer> values) {		int firstItem = 0;				for (int i = 0; i < values.size(); i++) {			if (i == 0) firstItem = values.get(i);						if ( values.get(i) != firstItem ) 				return false;		}				return true;	}		private ChessPlay getChessPlayFromString(String moveAsString) {		String[] array = moveAsString.split("to");		String from = array[0].trim();		String to = array[1].trim();				ChessPlay play = new ChessPlay();				play.setColumnFrom(from.substring(0, 1));		play.setColumnTo(to.substring(0, 1));		play.setRowFrom(Integer.parseInt(from.substring(1, 2)));		play.setRowTo(Integer.parseInt(to.substring(1, 2)));				return play;	}	public String getBestPlay(List<?> actions) {		if ( actions.size() >= 1) 			return (String) actions.get(0);		return null;	}		public void reset() {		this.createBoard();	}}